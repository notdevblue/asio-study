지금까지의 예시를 통해 asio 가 통신의 시간적 부분을 매우 잘 처리한다는걸 알 수 있음,
올바른 시간과 조건에 코드를 실행할 수 있게 해주기 때문.

하지만 HTTP 예시는 하나의 흥미로운 문제점을 알려줌,
얼마나 많은 데이터들이 보내지는지 모름,
비디오 스트리밍같은 흥미로운 앱들의 요구사항이긴 하지만 실제로 작업하기 매우 불편함.

HTTP 응답 헤더에는 데이터 길이를 알려주는 바이트가 있음,
그걸 파싱해서 버퍼를 생성할 수 있지만 이제부터 만드는 프레임워크에선 조금 다르게 처리할 것.

우리의 모든 데이터 전달에는 메세지를 포함할 것
그리고 두개의 주요 컴포넌트가 있음
1. 헤더
    a. 이 메세지가 무엇인지에 대한 identifier
    b. 헤더를 포함한 메세지 전체의 바이트 크기
2. 바디
    a. 메세지의 Payload 임 (0 + n 바이트)
       이벤트 같은 메세지는 바디가 필요 없기 때문임

이런 형식으로 데이터를 전달하게 되면, 우리는 절대 사이즈를 모르는 데이터를 전달하거나 읽지 않음.
헤더는 항상 먼저 전송되고, 이는 고정된 크기임.
하지만 헤더 이후에 오는 바디를 읽기 위해 필요한 버퍼의 크기를 준비하기 위한 정보를 포함하고 있음.

헤더의 ID 는 헤더를 구분 짓는 용도로 사용됨,
간단하게 int 형식일 수 있음, 하지만 C++ 은 더욱 모던한 툴을 지원함, 헤더가 정확한지 아닌지를 컴파일 시간에 검증할 수 있음!
그래서 int 대신, enum class 를 정의할 것.
enum class 는 enum 구조체랑 비슷함.
<열거형 안에 그 문자 (심볼)> 와 값으로 이루어짐
https://blockdmask.tistory.com/405

이 상황에서는 심볼에 값이 할당되진 않음, 컴파일러 식별자로 사용함
enum class 는 강한 타입이기 때문에, 컴파일러는 우리가 올바르지 못한 id 를 전달하는 경우 알 수 있음.

만약 우리가 integer 를 사용했다면, 우리 코드에는 버그, 아무 의미 없는 id 를 보낼 가능성이 있음.
사실 시스템에서 확인하고 걸러낼 수 있지만, 컴파일러가 대신 해주고 우리한테 알려주면 얼마나 좋음.

이와 같이 enum class 를 사용하는 것의 한가지 문제는 그렇게 유연하지 않다는 것임.
앱에 네트워킹을 원하는 모든 사용자에게 제공하고 싶기 때문에, 무슨 메세지 타입이 필요한지 모름.
몇백만개의 심볼이 있는 enum class 를 작성할 순 없으니,
유저가 직접 enum class 를 정의할 수 있게 할 것임.
그리고 Template 를 이용해서 메세지를 커스터마이징 할 수 있게 할 것임.

이 방식을 통해 우리의 프레임워크는 예측이 가능하게 작동할 수 있고,
유저가 직접 정의한 메세지를 사용할 수 있음

데이터는 전송될 때 매우 연속적으로 전달됨,
그래서 간단하게 직렬, 역직렬화 할수 있는 기능을 메세지 타입에 추가할 것.
이는 유저가 메세지 타입을 쉽게 사용할 수 있게 할 것

희망적으로 모든 데이터 트렌젝션을 이미 정의된 메세지를 사용하도록 억제하게 되면,
클라이언트와 서버 인터페이스는 유저의 추가적인 수정 없이 정의될 수 있음.
