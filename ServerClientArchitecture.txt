메세지 형식이 확정됬으니, 메세지가 시스템 사이에서 어떻게 움직이는지 생각해야 함
서버-클라이언트 프레임워크에선 항상 두개로 나눠짐
하나는 클라이언트, 하나는 서버임

MMO 에선, 대부분의 클라이언트는 플레이어임;
맵 곳곳을 뛰어다니는.

서버는 몇가지의 역할들을 이행함.
1. 클라이언트 간 정보 교환을 가능하게 함
2. 게임 그 자체를 돌림. 게임 월드에서 무슨 일이 일어나는 지에 대한 책임이 있음

게임을 만들 때 나중에 갈 수록 네트워크같은 좁은 공간에 (shoehorn. 구두 주걱이라는 의미를 가지고 있음) 밀어넣는건 매우 어려움
그래서 개발 0일차부터 네트워크를 사용한다는걸 기반으로 게임의 구조를 생각해보는건 좋음
그리고 다음 몇몇 에피소드에서 더 알아가 볼 것임.
하지만 지금은 메세지를 어떻게 이동시킬지에 대해 집중할 것.

클라이언트는 클라이언트에서 할 일들을 돌릴 것.
돌리는 동안 아무 메세지가 도착했는지 확인함.
확인 사이사이에, 여러 메세지가 도착했을 가능성이 있음
그래서 도착한 메세지들은 입력 메세지 큐에 보관할 것.
그리고 클라이언트는 어느 시점에서나 서버에게 메세지를 전송할 수 있음.

비슷한 방식으로, 서버도 항상 돌아감.
그리고 정기적으로 도착한 메세지가 있는지 큐를 확인함.
서버도 아무때나 메세지를 보낼 수 있음.

개념적으로, 클라이언트는 서버와의 연결이 있고, 서버는 클라이언트와의 연결이 있다고 생각할 것
이 두 연결은, asio와 socket을 통해 연결되어 있음

연결은 보내지는 메세지들을 모아서 전송함
하지만 연결을 들어오는 메세지들도 받아서 클라이언트나 서버의 큐에 집어넣음

asio와 socket 프레임워크는 약간의 변화가 존재함
클라이언트는 하나의 연결만 가질 수 있지만 서버는 여러 연결을 가질 수 있음
그래서 서버는 클라이언트 각각 출력하거나, 전부 한번에 출력할 수 있음.

하지만 이 프레임워크에서의 중요한 기능은,
서버에는 오직 하나의 메세지 입력 큐만 있다는 것임.
이렇게 되면, 서버는 싱글 스레드에서 작동할 수 있음;
잘하면 클라이언트에게서 보내진 메세지에 순서대로 답장하도록.

구조를 그리게 되면 주로 사용되는 컴포넌트가 무엇인지 알기 상당히 유용함
하나 보이는 것은 Queue들이 있다, 다 같은 것들인; 메세지 들을 가지고 있음.
그래서 우리는 Queue 구조체가 필요하다는걸 암.
그리고 연결 오브젝트들을 잘 보게 되면, y 축 대칭이기도 하지만, 연결 오브젝트 자체가 동일하다는것도 알 수 있음.
그래서 연결 오브젝트들도 필요하다는걸 알게 됨.
클라이언트는 같은 인터페이스를 공유할 것. 그래서 클라이언트 인터페이스 오브젝트도 만들어야 한다고 생각함.
그리고 서버, 서버는 특별하고 클라이언트랑은 다름, 여러 클라이언트랑 접속이 가능하다는 것임; 여러 커넥션 오브젝트를 사용해서

또, 프레임워크는 asio 특정 코드들을 충분이 추상화 함
근본적으로 클라이언트나 서버가 구현하는 아무 것들은, 실제로 어떻게 네트워크 코드가 동작하는지 고려할 필요가 없음.

이제 몇개의 추가 인터페이스를 코드에 작성할 것임.
